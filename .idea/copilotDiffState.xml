<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# Batalha Naval Master&#10;&#10;**MATÉRIA:** `PDSI I - UNIVERSIDADE FEDERAL DE UBERLÂNDIA`&#10;&#10;&#10;## Sobre o Projeto&#10;Este é um sistema completo de Batalha Naval, desenvolvido em Java (back-end) com Spark Java, autenticação via Firebase, e front-end em JavaScript. O projeto suporta partidas contra o computador, histórico de partidas, autenticação de usuários e interface web moderna.&#10;&#10;## Pré-requisitos&#10;Para executar e desenvolver este projeto, você precisará dos seguintes pré-requisitos:&#10;&#10;- **Java 24** (compilação e execução)&#10;- **Maven 3.8+** (gerenciamento de dependências e build)&#10;- **Conta no Firebase** (para autenticação e banco de dados)&#10;- **Node.js** e **npm** (opcional, para testes front-end com Jest)&#10;&#10;&gt; As versões de Java e Maven são baseadas no arquivo `pom.xml` e no workflow de CI. O projeto utiliza Java 24 (Temurin) e Maven para build e testes.&#10;&#10;## Ferramentas, Bibliotecas e Tecnologias Utilizadas&#10;&#10;- **Linguagem principal:** Java 24&#10;- **Gerenciador de dependências:** Maven&#10;- **Framework Web:** Spark Java 2.9.4&#10;- **Autenticação e Banco de Dados:** Firebase Admin SDK 9.1.1 (Firestore)&#10;- **Serialização JSON:** Gson 2.10.1&#10;- **Logging:** SLF4J Simple 1.7.36&#10;- **Testes Java:** JUnit Jupiter 5.9.2, Mockito 5.2.0&#10;- **Testes Front-end:** Jest (JavaScript, opcional)&#10;- **Front-end:** HTML, CSS, JavaScript (puro)&#10;&#10;&gt; Todas as versões das bibliotecas Java estão especificadas no `pom.xml`. O front-end utiliza apenas recursos nativos do navegador e testes opcionais com Jest.&#10;&#10;## Como executar o projeto&#10;&#10;### Windows&#10;1. Abra o Prompt de Comando ou PowerShell na raiz do projeto.&#10;2. Execute:&#10;   ```&#10;   mvn clean package&#10;   java -cp target/BatalhaNaval-1.0-SNAPSHOT.jar battleship.application.MainApplication&#10;   ```&#10;&#10;### macOS&#10;1. Abra o Terminal na raiz do projeto.&#10;2. Execute:&#10;   ```&#10;   mvn clean package&#10;   java -cp target/BatalhaNaval-1.0-SNAPSHOT.jar battleship.application.MainApplication&#10;   ```&#10;&#10;O servidor estará disponível em `http://localhost:8080`.&#10;&#10;## Como executar os testes&#10;&#10;### Testes back-end (Java)&#10;No terminal (Windows ou Mac), execute:&#10;```&#10;mvn test&#10;```&#10;Os resultados aparecerão no console e em `target/surefire-reports/`.&#10;&#10;### Testes front-end (JavaScript)&#10;Se desejar rodar os testes do front-end (Jest):&#10;1. Instale o Jest globalmente ou no projeto:&#10;   ```&#10;   npm install --global jest&#10;   # ou&#10;   npm install --save-dev jest&#10;   ```&#10;2. Execute:&#10;   ```&#10;   npx jest&#10;   ```&#10;&#10;## Como simular testes falhos ou ignorados&#10;&#10;### Para forçar uma falha em um teste Java&#10;Altere um valor esperado em um teste, por exemplo em `GameServiceImplTest.java`:&#10;```java&#10;@Test&#10;public void testInitGame() {&#10;    InitResponse resp = service.initGame(new InitRequest(7));&#10;    // Espera 7, mas força erro esperando 8&#10;    assertEquals(8, resp.getSize());&#10;}&#10;```&#10;&#10;### Para pular (ignorar) um teste Java&#10;Adicione a anotação `@Disabled`:&#10;```java&#10;import org.junit.jupiter.api.Disabled;&#10;&#10;@Disabled(&quot;Ignorado para demonstração&quot;)&#10;@Test&#10;public void testInitGame() {&#10;    // ...&#10;}&#10;```&#10;&#10;### Para forçar erro em um teste Java&#10;Lance uma exceção manualmente:&#10;```java&#10;@Test&#10;public void testForcaErro() {&#10;    throw new RuntimeException(&quot;Erro proposital&quot;);&#10;}&#10;```&#10;&#10;### Para simular falha em teste front-end (Jest)&#10;Altere um valor esperado em `api.test.js`:&#10;```js&#10;test('deve falhar propositalmente', () =&gt; {&#10;    expect(1 + 1).toBe(3);&#10;});&#10;```&#10;&#10;## Integração Contínua (CI)&#10;&#10;Este projeto utiliza GitHub Actions para garantir a qualidade do código a cada commit e pull request. O workflow de CI:&#10;- Faz checkout do repositório&#10;- Configura o Java 24&#10;- Realiza build e executa todos os testes com Maven&#10;- Só permite o build se todos os testes passarem&#10;&#10;O arquivo de configuração está em `.github/workflows/ci.yml`.&#10;&#10;## O que cada teste faz&#10;&#10;### Testes de domínio&#10;- **BoardTest**: Testa posicionamento de navios, sobreposição, limites do tabuleiro, ataques (acerto/erro) e verificação de fim de jogo.&#10;- **ShipTest**: Testa geração de coordenadas do navio (horizontal/vertical), ocupação, registro de acertos e afundamento.&#10;- **CoordinateTest**: Testa igualdade, hashCode e métodos getters da coordenada.&#10;- **ShipFactoryTest**: Testa se a fábrica cria navios corretamente com o tamanho esperado.&#10;&#10;### Testes de exceção&#10;- **BadRequestExceptionTest**: Testa se a exceção retorna a mensagem correta.&#10;&#10;### Testes de serviço&#10;- **GameServiceImplTest**: Testa inicialização do jogo, posicionamento de navio do jogador (válido e inválido), ataques do jogador e do computador.&#10;&#10;### Testes front-end (Jest)&#10;- **api.test.js**: Testa a função `addHistory` para garantir que lida corretamente com respostas de sucesso e erro do back-end.&#10;&#10;## Banco de Dados&#10;&#10;O modelo de banco de dados noSQL do Batalha Naval Master foi desenhado para ser flexível, escalável e aderente aos requisitos do projeto, sendo totalmente compatível com o Firestore do Firebase. Cada coleção representa um conjunto de documentos, e os campos podem ser tipos primitivos, arrays ou referências por ID, seguindo o padrão do Firestore.&#10;&#10;### Estrutura e Implementação Atual&#10;&#10;- **Coleções já implementadas:**&#10;  - **users:** cada usuário é um documento nesta coleção.&#10;    - **games:** subcoleção dentro de cada usuário, onde são armazenados os históricos de partidas daquele usuário (cada partida é um documento com os dados do jogo, resultado, timestamp, etc).&#10;&#10;- **Coleções previstas para próximas sprints (ainda não implementadas):**&#10;  - **Games:** coleção global de partidas.&#10;  - **GameHistory:** histórico detalhado de partidas global.&#10;  - **Invitations:** convites e agendamento de partidas.&#10;  - **GameSettings:** preferências do usuário.&#10;  - **ChatMessages:** mensagens trocadas durante as partidas (chat in-game).&#10;  - **Friends:** gerenciamento de amizades e solicitações.&#10;  - **AISettings:** níveis e comportamentos da IA.&#10;  - **Reports:** relatórios e feedbacks de partidas.&#10;&#10;### Esquema Gráfico Completo (dbdiagram.io)&#10;&#10;O esquema abaixo representa **todas as coleções e relacionamentos previstos nos requisitos do projeto**, incluindo as já implementadas e as planejadas para o futuro. Use este modelo para documentação, discussão com o time e planejamento de evolução do banco. Ele pode ser importado no [dbdiagram.io](https://dbdiagram.io):&#10;&#10;```dbml&#10;Table Users {&#10;  userId string [pk]&#10;  username string&#10;  photoUrl string&#10;  winCount int&#10;  loseCount int&#10;  gamesPlayed int&#10;  friends string[]&#10;  lastLogin datetime&#10;}&#10;&#10;Table Games {&#10;  gameId string [pk]&#10;  player1Id string [ref: &gt; Users.userId]&#10;  player2Id string [ref: &gt; Users.userId]&#10;  player1MoveHistory string[]&#10;  player2MoveHistory string[]&#10;  status string&#10;  winnerId string [ref: &gt; Users.userId]&#10;  boardSize int&#10;  turnCount int&#10;  gameStart datetime&#10;  gameEnd datetime&#10;  isOnline boolean&#10;  difficultyLevel string&#10;  player1ShipPositions string[]&#10;  player2ShipPositions string[]&#10;}&#10;&#10;Table GameHistory {&#10;  gameHistoryId string [pk]&#10;  gameId string [ref: &gt; Games.gameId]&#10;  player1Id string [ref: &gt; Users.userId]&#10;  player2Id string [ref: &gt; Users.userId]&#10;  result string&#10;  moves string[]&#10;  finalBoard string&#10;  gameDate datetime&#10;}&#10;&#10;Table Invitations {&#10;  invitationId string [pk]&#10;  senderId string [ref: &gt; Users.userId]&#10;  receiverId string [ref: &gt; Users.userId]&#10;  status string&#10;  gameId string [ref: &gt; Games.gameId]&#10;  inviteTime datetime&#10;  responseTime datetime&#10;}&#10;&#10;Table GameSettings {&#10;  userId string [pk, ref: &gt; Users.userId]&#10;  defaultBoardSize int&#10;  preferredDifficulty string&#10;  autoShipPlacement boolean&#10;  notificationsEnabled boolean&#10;}&#10;&#10;Table ChatMessages {&#10;  messageId string [pk]&#10;  gameId string [ref: &gt; Games.gameId]&#10;  senderId string [ref: &gt; Users.userId]&#10;  receiverId string [ref: &gt; Users.userId]&#10;  message string&#10;  timestamp datetime&#10;}&#10;&#10;Table Friends {&#10;  userId string [pk, ref: &gt; Users.userId]&#10;  friendsList string[]&#10;  requestSent string[]&#10;  requestReceived string[]&#10;}&#10;&#10;Table AISettings {&#10;  aiLevel string [pk]&#10;  aiBehavior string&#10;}&#10;&#10;Table Reports {&#10;  reportId string [pk]&#10;  gameId string [ref: &gt; Games.gameId]&#10;  report string&#10;  timestamp datetime&#10;}&#10;```&#10;&#10;&gt; **Nota:** Apenas a coleção `users` (com subcoleção `games`) está implementada atualmente. As demais fazem parte do roadmap aprovado e serão implementadas conforme a evolução do projeto. Algumas tabelas/coleções decididas aqui ainda poderão ser alteradas ou até não estar presentes na versão final da entrega, dependendo das decisões de implementação e priorização ao longo do desenvolvimento. Além disso, a subcoleção `games` não está totalmente implementada até o momento desta apresentação, podendo sofrer mudanças ou expansões.&#10;&#10;### Observações Importantes&#10;- O modelo cobre as funcionalidades essenciais atuais (autenticação e histórico de partidas por usuário).&#10;- O uso do padrão noSQL permite adicionar coleções e campos sem grandes refatorações, garantindo flexibilidade e escalabilidade.&#10;- O modelo é totalmente compatível com o Firestore do Firebase, bastando criar as coleções e documentos conforme a estrutura acima.&#10;&#10;## Licença&#10;Este projeto está sob a licença MIT.&#10;" />
              <option name="updatedContent" value="# Batalha Naval Master&#10;&#10;**MATÉRIA:** `PDSI I - UNIVERSIDADE FEDERAL DE UBERLÂNDIA`&#10;&#10;&#10;## Sobre o Projeto&#10;Este é um sistema completo de Batalha Naval, desenvolvido em Java (back-end) com Spark Java, autenticação via Firebase, e front-end em JavaScript. O projeto suporta partidas contra o computador, histórico de partidas, autenticação de usuários e interface web moderna.&#10;&#10;## Pré-requisitos&#10;Para executar e desenvolver este projeto, você precisará dos seguintes pré-requisitos:&#10;&#10;- **Java 24** (compilação e execução)&#10;- **Maven 3.8+** (gerenciamento de dependências e build)&#10;- **Conta no Firebase** (para autenticação e banco de dados)&#10;- **Node.js** e **npm** (opcional, para testes front-end com Jest)&#10;&#10;&gt; As versões de Java e Maven são baseadas no arquivo `pom.xml` e no workflow de CI. O projeto utiliza Java 24 (Temurin) e Maven para build e testes.&#10;&#10;## Ferramentas, Bibliotecas e Tecnologias Utilizadas&#10;&#10;- **Linguagem principal:** Java 24&#10;- **Gerenciador de dependências:** Maven&#10;- **Framework Web:** Spark Java 2.9.4&#10;- **Autenticação e Banco de Dados:** Firebase Admin SDK 9.1.1 (Firestore)&#10;- **Serialização JSON:** Gson 2.10.1&#10;- **Logging:** SLF4J Simple 1.7.36&#10;- **Testes Java:** JUnit Jupiter 5.9.2, Mockito 5.2.0&#10;- **Testes Front-end:** Jest (JavaScript, opcional)&#10;- **Front-end:** HTML, CSS, JavaScript (puro)&#10;&#10;&gt; Todas as versões das bibliotecas Java estão especificadas no `pom.xml`. O front-end utiliza apenas recursos nativos do navegador e testes opcionais com Jest.&#10;&#10;## Como executar o projeto&#10;&#10;### Windows&#10;1. Abra o Prompt de Comando ou PowerShell na raiz do projeto.&#10;2. Execute:&#10;   ```&#10;   mvn clean package&#10;   java -cp target/BatalhaNaval-1.0-SNAPSHOT.jar battleship.application.MainApplication&#10;   ```&#10;&#10;### macOS&#10;1. Abra o Terminal na raiz do projeto.&#10;2. Execute:&#10;   ```&#10;   mvn clean package&#10;   java -cp target/BatalhaNaval-1.0-SNAPSHOT.jar battleship.application.MainApplication&#10;   ```&#10;&#10;O servidor estará disponível em `http://localhost:8080`.&#10;&#10;## Como executar os testes&#10;&#10;### Testes back-end (Java)&#10;No terminal (Windows ou Mac), execute:&#10;```&#10;mvn test&#10;```&#10;Os resultados aparecerão no console e em `target/surefire-reports/`.&#10;&#10;## Como simular testes falhos ou ignorados&#10;&#10;### Para forçar uma falha em um teste Java&#10;Altere um valor esperado em um teste, por exemplo em `GameServiceImplTest.java`:&#10;```java&#10;@Test&#10;public void testInitGame() {&#10;    InitResponse resp = service.initGame(new InitRequest(7));&#10;    // Espera 7, mas força erro esperando 8&#10;    assertEquals(8, resp.getSize());&#10;}&#10;```&#10;&#10;### Para pular (ignorar) um teste Java&#10;Adicione a anotação `@Disabled`:&#10;```java&#10;import org.junit.jupiter.api.Disabled;&#10;&#10;@Disabled(&quot;Ignorado para demonstração&quot;)&#10;@Test&#10;public void testInitGame() {&#10;    // ...&#10;}&#10;```&#10;&#10;### Para forçar erro em um teste Java&#10;Lance uma exceção manualmente:&#10;```java&#10;@Test&#10;public void testForcaErro() {&#10;    throw new RuntimeException(&quot;Erro proposital&quot;);&#10;}&#10;```&#10;&#10;## Integração Contínua (CI)&#10;&#10;Este projeto utiliza GitHub Actions para garantir a qualidade do código a cada commit e pull request. O workflow de CI:&#10;- Faz checkout do repositório&#10;- Configura o Java 24&#10;- Realiza build e executa todos os testes com Maven&#10;- Só permite o build se todos os testes passarem&#10;&#10;O arquivo de configuração está em `.github/workflows/ci.yml`.&#10;&#10;## O que cada teste faz&#10;&#10;### Testes de domínio&#10;- **BoardTest**: Testa posicionamento de navios, sobreposição, limites do tabuleiro, ataques (acerto/erro) e verificação de fim de jogo.&#10;- **ShipTest**: Testa geração de coordenadas do navio (horizontal/vertical), ocupação, registro de acertos e afundamento.&#10;- **CoordinateTest**: Testa igualdade, hashCode e métodos getters da coordenada.&#10;- **ShipFactoryTest**: Testa se a fábrica cria navios corretamente com o tamanho esperado.&#10;&#10;### Testes de exceção&#10;- **BadRequestExceptionTest**: Testa se a exceção retorna a mensagem correta.&#10;&#10;### Testes de serviço&#10;- **GameServiceImplTest**: Testa inicialização do jogo, posicionamento de navio do jogador (válido e inválido), ataques do jogador e do computador.&#10;&#10;## Banco de Dados&#10;&#10;O modelo de banco de dados noSQL do Batalha Naval Master foi desenhado para ser flexível, escalável e aderente aos requisitos do projeto, sendo totalmente compatível com o Firestore do Firebase. Cada coleção representa um conjunto de documentos, e os campos podem ser tipos primitivos, arrays ou referências por ID, seguindo o padrão do Firestore.&#10;&#10;### Estrutura e Implementação Atual&#10;&#10;- **Coleções já implementadas:**&#10;  - **users:** cada usuário é um documento nesta coleção.&#10;    - **games:** subcoleção dentro de cada usuário, onde são armazenados os históricos de partidas daquele usuário (cada partida é um documento com os dados do jogo, resultado, timestamp, etc).&#10;&#10;- **Coleções previstas para próximas sprints (ainda não implementadas):**&#10;  - **Games:** coleção global de partidas.&#10;  - **GameHistory:** histórico detalhado de partidas global.&#10;  - **Invitations:** convites e agendamento de partidas.&#10;  - **GameSettings:** preferências do usuário.&#10;  - **ChatMessages:** mensagens trocadas durante as partidas (chat in-game).&#10;  - **Friends:** gerenciamento de amizades e solicitações.&#10;  - **AISettings:** níveis e comportamentos da IA.&#10;  - **Reports:** relatórios e feedbacks de partidas.&#10;&#10;### Esquema Gráfico Completo (dbdiagram.io)&#10;&#10;O esquema abaixo representa **todas as coleções e relacionamentos previstos nos requisitos do projeto**, incluindo as já implementadas e as planejadas para o futuro. Use este modelo para documentação, discussão com o time e planejamento de evolução do banco. Ele pode ser importado no [dbdiagram.io](https://dbdiagram.io):&#10;&#10;```dbml&#10;Table Users {&#10;  userId string [pk]&#10;  username string&#10;  photoUrl string&#10;  winCount int&#10;  loseCount int&#10;  gamesPlayed int&#10;  friends string[]&#10;  lastLogin datetime&#10;}&#10;&#10;Table Games {&#10;  gameId string [pk]&#10;  player1Id string [ref: &gt; Users.userId]&#10;  player2Id string [ref: &gt; Users.userId]&#10;  player1MoveHistory string[]&#10;  player2MoveHistory string[]&#10;  status string&#10;  winnerId string [ref: &gt; Users.userId]&#10;  boardSize int&#10;  turnCount int&#10;  gameStart datetime&#10;  gameEnd datetime&#10;  isOnline boolean&#10;  difficultyLevel string&#10;  player1ShipPositions string[]&#10;  player2ShipPositions string[]&#10;}&#10;&#10;Table GameHistory {&#10;  gameHistoryId string [pk]&#10;  gameId string [ref: &gt; Games.gameId]&#10;  player1Id string [ref: &gt; Users.userId]&#10;  player2Id string [ref: &gt; Users.userId]&#10;  result string&#10;  moves string[]&#10;  finalBoard string&#10;  gameDate datetime&#10;}&#10;&#10;Table Invitations {&#10;  invitationId string [pk]&#10;  senderId string [ref: &gt; Users.userId]&#10;  receiverId string [ref: &gt; Users.userId]&#10;  status string&#10;  gameId string [ref: &gt; Games.gameId]&#10;  inviteTime datetime&#10;  responseTime datetime&#10;}&#10;&#10;Table GameSettings {&#10;  userId string [pk, ref: &gt; Users.userId]&#10;  defaultBoardSize int&#10;  preferredDifficulty string&#10;  autoShipPlacement boolean&#10;  notificationsEnabled boolean&#10;}&#10;&#10;Table ChatMessages {&#10;  messageId string [pk]&#10;  gameId string [ref: &gt; Games.gameId]&#10;  senderId string [ref: &gt; Users.userId]&#10;  receiverId string [ref: &gt; Users.userId]&#10;  message string&#10;  timestamp datetime&#10;}&#10;&#10;Table Friends {&#10;  userId string [pk, ref: &gt; Users.userId]&#10;  friendsList string[]&#10;  requestSent string[]&#10;  requestReceived string[]&#10;}&#10;&#10;Table AISettings {&#10;  aiLevel string [pk]&#10;  aiBehavior string&#10;}&#10;&#10;Table Reports {&#10;  reportId string [pk]&#10;  gameId string [ref: &gt; Games.gameId]&#10;  report string&#10;  timestamp datetime&#10;}&#10;```&#10;&#10;&gt; **Nota:** Apenas a coleção `users` (com subcoleção `games`) está implementada atualmente. As demais fazem parte do roadmap aprovado e serão implementadas conforme a evolução do projeto. Algumas tabelas/coleções decididas aqui ainda poderão ser alteradas ou até não estar presentes na versão final da entrega, dependendo das decisões de implementação e priorização ao longo do desenvolvimento. Além disso, a subcoleção `games` não está totalmente implementada até o momento desta apresentação, podendo sofrer mudanças ou expansões.&#10;&#10;### Observações Importantes&#10;- O modelo cobre as funcionalidades essenciais atuais (autenticação e histórico de partidas por usuário).&#10;- O uso do padrão noSQL permite adicionar coleções e campos sem grandes refatorações, garantindo flexibilidade e escalabilidade.&#10;- O modelo é totalmente compatível com o Firestore do Firebase, bastando criar as coleções e documentos conforme a estrutura acima.&#10;&#10;## Banco de Dados NoSQL e Arquitetura do Histórico&#10;&#10;O sistema utiliza um banco de dados NoSQL para armazenar o histórico das partidas. A seguir, um resumo da arquitetura e funcionamento dos principais componentes relacionados ao histórico:&#10;&#10;- **HistoryService**: Interface que define as operações de negócio para o histórico, como adicionar novos registros e buscar registros existentes. Sua implementação (HistoryServiceImpl) contém a lógica para persistência e validações desses dados no banco NoSQL.&#10;&#10;- **HistoryRequest**: DTO (Data Transfer Object) que encapsula os dados relacionados a uma operação de histórico. Esse objeto é utilizado para transportar as informações entre as camadas do sistema, por exemplo, do controlador para o serviço.&#10;&#10;- **HistoryController**: Componente responsável por expor endpoints HTTP (REST) para que clientes possam interagir com as operações do histórico. Ele recebe requisições, extrai os dados (mapeando para um HistoryRequest), chama os métodos do HistoryService e retorna respostas apropriadas.&#10;&#10;### Exemplo de fluxo&#10;1. O cliente faz uma requisição HTTP para adicionar ou buscar histórico.&#10;2. O `HistoryController` recebe a requisição e converte os dados recebidos em um `HistoryRequest`.&#10;3. O controller chama o método correspondente do `HistoryService`.&#10;4. O `HistoryServiceImpl` executa a lógica de negócio e persiste ou recupera os dados do banco NoSQL.&#10;5. A resposta é devolvida ao cliente.&#10;&#10;Essa arquitetura garante separação de responsabilidades, facilitando manutenção, testes e evolução do sistema.&#10;&#10;## Licença&#10;Este projeto está sob a licença MIT." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/jest.config.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/jest.config.js" />
              <option name="updatedContent" value="module.exports = {&#10;  testEnvironment: 'node',&#10;  testMatch: ['**/test/js/**/*.test.js'],&#10;};&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/js/api.test.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/js/api.test.js" />
              <option name="originalContent" value="// Teste unitário para a função addHistory do front-end usando Jest&#10;// Este teste simula uma chamada bem-sucedida e uma chamada com erro&#10;import { addHistory } from '../../src/main/resources/public/js/api.js';&#10;&#10;// Mock do fetch global&#10;beforeEach(() =&gt; {&#10;    global.fetch = jest.fn();&#10;});&#10;&#10;afterEach(() =&gt; {&#10;    jest.resetAllMocks();&#10;});&#10;&#10;describe('addHistory', () =&gt; {&#10;    it('deve resolver quando o status for 204', async () =&gt; {&#10;        fetch.mockResolvedValue({ status: 204 });&#10;        await expect(addHistory('win', 'computer')).resolves.toBeUndefined();&#10;    });&#10;&#10;    it('deve lançar erro se o status não for 204', async () =&gt; {&#10;        fetch.mockResolvedValue({ status: 400 });&#10;        await expect(addHistory('lose', 'user')).rejects.toThrow('Falha ao gravar histórico');&#10;    });&#10;});&#10;&#10;// Comentário: Este teste garante que a função addHistory lida corretamente com respostas de sucesso e erro do back-end.&#10;" />
              <option name="updatedContent" value="// Teste unitário para a função addHistory do front-end usando Jest&#10;// Este teste simula uma chamada bem-sucedida e uma chamada com erro&#10;const { addHistory } = require('../../src/main/resources/public/js/api.js');&#10;&#10;// Mock do fetch global&#10;beforeEach(() =&gt; {&#10;    global.fetch = jest.fn();&#10;});&#10;&#10;afterEach(() =&gt; {&#10;    jest.resetAllMocks();&#10;});&#10;&#10;describe('addHistory', () =&gt; {&#10;    it('deve resolver quando o status for 204', async () =&gt; {&#10;        fetch.mockResolvedValue({ status: 204 });&#10;        await expect(addHistory('win', 'computer')).resolves.toBeUndefined();&#10;    });&#10;&#10;    it('deve lançar erro se o status não for 204', async () =&gt; {&#10;        fetch.mockResolvedValue({ status: 400 });&#10;        await expect(addHistory('lose', 'user')).rejects.toThrow('Falha ao gravar histórico');&#10;    });&#10;});&#10;&#10;// Comentário: Este teste garante que a função addHistory lida corretamente com respostas de sucesso e erro do back-end." />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>